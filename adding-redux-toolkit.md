# Using Redux toolkit

This is the recommended way to implement redux in an app. Our application is simple, so for brevity during the workshop we will keep the structure of our application and put redux logic in its own folder. In a production app, we'd implement the 'Redux Ducks' approach, organising components into features and having them near the slice files that contain their redux logic.

## Getting the app set up to use Redux Toolkit:
1. run `npm i @reduxjs/toolkit` to install RTK
2. Create a `store.js` file in `src/redux`
    import `configureStore` from `@reduxjs/toolkit`
    We'll use this to configure our store:
    ```
    // We'll make the reducers that are imported here
    export default configureStore({
        reducer: {
            todos: todosReducer,
            filter: filterReducer
        }
    })
    ```

    3. Create a slice file for todos - `src/redux/todosSlice.js`:
    Here we'll define the reducers using ***mutable*** logic!
    ```
    import { createSlice } from "@reduxjs/toolkit";

    export const todosSlice = createSlice({
        name: 'todos',
        initialState: [],
        reducers: {
        
    }
    })

    ```
    4. Start defining the reducer functions. We don't need to use a switch statement here - Redux Toolkit will create actions for us base on the names of our reducer functions!
    ```
    export const todosSlice = createSlice({
        name: 'todos',
        initialState: [],
        reducers: {
            todoAdded(state, action) {
                // Remember, state at this level is an array of todos!
                // The payload will be a new todo object
                state.push(action.payload)
            }
            
        }
        })

    ```
    Add the required reducers for deleting a todo and updating its completion status

    5. Extract the actions from `todosSlice.actions` and export them:
    
    ```
    export const {todoAdded, deleteTodo, updateStatus} = todosSlice.actions
    ```
    It's also a good idea to write some selectors here to select data in the todos slice and export them for use in the app (write this from the point of view of the whole store):
    ```
    const selectTodos = state => state.todos
    
    ```
    Finally, export the reducer generated by `createSlice`:
    ```
    export default todosSlice.reducer
    ```

    6. Import the reducer into the `store.js` file:
    ```
        import { configureStore } from "@reduxjs/toolkit";
        // import todosReducer
        import todosReducer from '../redux/todosSlice'

        export default configureStore({
            reducer: {
                todos: todosReducer,
                filter: filterReducer
            }
        })


    ```
    7. Import the action to add a todo into the `AddTodo.jsx` component. Dispatch this in our `handleAddTodo` function:
    ```
    import React, { useState } from "react";
    import {useDispatch} from 'react-redux'
    //import redux actions
    import { todoAdded } from "../redux/todosSlice";
    // uuid v4 to create ids
    import { v4 } from 'uuid'

    export default function AddTodo({addNewTodo}) {
        const [todoText, setTodoText] = useState("");
        const dispatch = useDispatch()
        
        function handleAddTodo(e) {
            e.preventDefault()
            dispatch(todoAdded({
                id: v4(),
                text: todoText,
                status: 'incomplete'
            }))
            setTodoText("")
        }
    ```
    Add the other actions to the appropriate parts of the code. The `Todo` component needs to be able to dispatch actions to delete itself todo or update its status.

    8. Use `useSelect` and a selector to get todos from the store to render in the `TodoContainer` component:
    ```
    import { selectTodos } from '../redux/todosSlice'
    import { useSelector } from 'react-redux'
    export default function TodoContainer() {
        const [filter, setFilter] = useState(false)
        const todosFromStore = useSelector(selectTodos)
        // ... filter and render logic...
    }
    ```

    9. Our todos side of the state is set up now. If you started working from the basic version of the app (main branch), you'll find that the `useState` logic is allowing us to set the filter on and off. This is ideal in this scenario, but see if you can implement the filter slice
    - use `createSlice` to create the slice, add initial state and add a reducer to toggle the filter state
    - Export actions and selectors and reducer from the slice file
    - Add the reducer to the store
    - Use `useDispatch` and `useSelector` to set and retrieve the filter state in `TodoContainer`.
    - Marvel at the world's best Redux app.



# Fetching data from the server:
We're using json-server to mock a server for this workshop, but the logic will be the same for a real server. The 'database' is held in `db.json`.

Before you get started, start the json server using `json-server --watch db.json`

Let's convert our app to fetch, retrieve and edit todos on the server:

    1. Inside `todosSlice.js`:
    import `createAsyncThunk` from `@reduxjs/toolkit`

    2. Let's create a thunk to fetch todos:
        `createAsyncThunk` take two parameters, an type string that will be dispatched to the store, and an action creator to create a payload.
        ```
        const loadTodos = createAsyncThunk('todos/loadTodos', async () => {
            const response = await fetch("http://localhost:3000/todos");
            const todos = await response.json()
            console.log(todos)
            return todos
        })
        ```
    3. `createSlice` doesn't make a reducer to deal with this thunk, so we add the reducers to the 'extraReducers' field in our slice object. We can user the 'builder' syntax to create reducers that deal with the pending, fulfilled and rejected responses we might get from the server. `createAsyncThunk` lets us handle all these cases as it deals with the async logic involved in fetching from the server:

    ```
     extraReducers: builder => {
        builder
            .addCase(loadTodos.fulfilled, (state, action) => {
            return action.payload
        })

    ```
    We could add extra logic here to handle loading or failed states, then show these in the UI.

    In `extraReducers`, we can either modify the state directly, or return a new state. Here's the full logic for the final app:
    ```
    extraReducers: builder => {
        builder
            .addCase(loadTodos.fulfilled, (state, action) => {
           
            return action.payload
            })
            .addCase(deleteTodo.fulfilled, (state, action) => {
                console.log(action)
                const newState = state.filter(todo => todo.id !== action.payload)
                return newState
            })
            .addCase(updateTodo.fulfilled, (state, action) => {
                const {id, status} = action.payload
            state.find(todo => todo.id === id).status = status
            })
            .addCase(addTodo.fulfilled, (state, action) => {
                state.push(action.payload)
                
        })
    ```

    4. Let's write the logic for deleting and updating todos.

    5. We'll import our 'loadTodos' function into the `TodoContainer`.
    We dispatch this inside a `useEffect` call so that the component starts loading todos when it is rendered.

    ```
        useEffect(() => {
            dispatch(loadTodos())
        })
    ```

    6. We'll also update the `AddTodo` and `Todo` components:
    ```
    // Inside AddTodo.jsx
     function handleAddTodo(e) {
        e.preventDefault()
		dispatch(
			addTodo({
				id: v4(),
				text: todoText,
				status: "incomplete",
			})
		);
        setTodoText("")
    }


    ```

    ```
    // Inside Todo.jsx
    <button onClick={() => dispatch(deleteTodo(id))} className='delete'>Delete</button>
      <select value={todoData.status} onChange={e => dispatch(updateTodo({id, status: e.target.value}))}>

    ```
    7. Continue in the same way, and we should have a fully working app!








